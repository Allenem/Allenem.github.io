<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[我的第一篇hexo博客测试文章]]></title>
    <url>%2F2019%2F04%2F27%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87hexo%E5%8D%9A%E5%AE%A2%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[note 样式Bootstrap Callout 由 ivan-nginx 贡献这些样式出现在 Bootstrap 的官方文档中。 使用方式1&#123;% note class_name %&#125; Content (md partial supported) &#123;% endnote %&#125; 其中，class_name 可以是以下列表中的一个值： default primary success info warning danger 示例如下： Content (md partial supported) Content (md partial supported) Content (md partial supported) Content (md partial supported) Content (md partial supported) Content (md partial supported) 如何设置「阅读全文」在首页显示一篇文章的部分内容，并提供一个链接跳转到全文页面是一个常见的需求。 NexT 提供三种方式来控制文章在首页的显示方式。 也就是说，在首页显示文章的摘录并显示 阅读全文 按钮，可以通过以下方法： 在文章中使用 &lt;!– more –&gt; 手动进行截断，Hexo 提供的方式 推荐 在文章的 front-matter 中添加 description，并提供文章摘录 自动形成摘要，在主题配置文件中添加：123auto_excerpt: enable: true length: 150 默认截取的长度为 150 字符，可以根据需要自行设定 建议使用 &lt;!– more –&gt; （即第一种方式），除了可以精确控制需要显示的摘录内容以外， 这种方式也可以让 Hexo 中的插件更好的识别。 $$\mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix}\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\frac{\partial X}{\partial u} &amp; \frac{\partial Y}{\partial u} &amp; 0 \\frac{\partial X}{\partial v} &amp; \frac{\partial Y}{\partial v} &amp; 0 \\end{vmatrix}$$tep1}{\style{visibility:hidden}{(x+1)(x+1)}}$$ 文本居中的引用此标签将生成一个带上下分割线的引用，同时引用内文本将自动居中。 文本居中时，多行文本若长度不等，视觉上会显得不对称，因此建议在引用单行文本的场景下使用。 例如作为文章开篇引用 或者 结束语之前的总结引用。 使用方式 HTML方式：使用这种方式时，给 img 添加属性 class=”blockquote-center” 即可。 标签方式：使用 centerquote 或者 简写 cq。此标签要求 NexT 的版本在 0.4.5 或以上。 若你正在使用的版本比较低，可以选择使用 HTML 方式。 代码和效果如下： 123&lt;!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 --&gt;&lt;!-- 其中 class="blockquote-center" 是必须的 --&gt;&lt;blockquote class="blockquote-center"&gt;blah blah blah&lt;/blockquote&gt; blah blah blah12&lt;!-- 标签 方式，要求版本在0.4.5或以上 --&gt;&#123;% centerquote %&#125;blah blah blah&#123;% endcenterquote %&#125; blah blah blah 12&lt;!-- 标签别名 --&gt;&#123;% cq %&#125; blah blah blah &#123;% endcq %&#125; blah blah blah 添加评论为你的Hexo加上评论系统-Valinehttps://blog.csdn.net/blue_zy/article/details/79071414 添加统计站点访问计数有名的就是不蒜子，使用起来非常方便 next主题详细配置Hexo的Next主题详细配置https://www.jianshu.com/p/3a05351a37dc Hexo搭建博客无坑操作具体运用Hexo搭建博客建议无坑操作请看 CodeSheep 的 手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo Mackxin 的 使用Hexo博客搭建的个人博客，使用Next主题来进行优化改造]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Testing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>Testing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue + Express (node.js) 搭建我的初始博客之旅]]></title>
    <url>%2F2019%2F04%2F23%2FVue%2BExpress%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[特别感谢特羊普的视频vue + nodejs搭建自己的博客 #1初始化Vue脚手架1vue init webpack blog #2进入blog文件夹安装依赖1cnpm install #3在blog文件夹启动1npm start #4退回Blog文件夹全局安装express1npm install express-generator -g #5exppress搭建后端1express back #6进入back文件夹安装依赖1cnpm install #7在back文件夹启动1npm start 从package.json文件可以看到1"start": "node ./bin/www" 从app.js看到1234app.use(express.static(path.join(__dirname, 'public')));app.use('/', indexRouter);app.use('/users', usersRouter); 将public文件夹清空新建index.htmlrouters/index.js中有1234/* GET home page. */router.get('/', function(req, res, next) &#123; res.render('index', &#123; title: 'Express' &#125;);&#125;); 则优先路由到public/index.html #8前端页面Header、Home、About的搭建blog文件夹中 components文件夹添加几个组件Header.vue、Home.vue、About.vue、Note.vue index.js添加路由 1234import Header from '@/components/Header'import Home from '@/components/Home'import About from '@/components/About'import Note from '@/components/Note' 123456789101112131415161718192021222324252627282930313233343536export default new Router(&#123; routes: [ &#123; path: '/', //下面两行去除，重定向到index路由 //name: 'HelloWorld', //component: HelloWorld redirect: '/index' &#125;, //以下为添加的路由 &#123; path: '/index', name: 'index', components: &#123; header:Header, main:Home &#125; &#125;, &#123; path: '/about', name: 'about', components: &#123; header:Header, main:About &#125; &#125;, &#123; path: '/note', name: 'note', components: &#123; header:Header, main:Note &#125; &#125;, ]&#125;) App.vue根组件引入 12&lt;router-view name="header"/&gt;&lt;router-view name="main"/&gt; 填写App.vue等样式和内容 填写header组件图片、li选中和跳转逻辑，以及处理小bug 12345&lt;li class="menu-item" v-for="(item,index) in list" :key="item.title"&gt; &lt;router-link :class="&#123;'menu-item-select':itemCheck==index&#125;" :to="item.path" @click.native="tabClass(index)"&gt; &#123;&#123;item.title&#125;&#125; &lt;/router-link&gt;&lt;/li&gt; 123&lt;router-link to="/index" @click.native="tabClass(0)"&gt; &lt;img src="../assets/logo.jpg" alt=""&gt;&lt;/router-link&gt; 12345678910111213141516171819202122232425262728293031323334353637// script部分 data() &#123; return &#123; list:[ &#123; title: 'home', path: '/index' &#125;, &#123; title: 'about', path: '/about' &#125;, &#123; title: 'note', path: '/note' &#125; ], itemCheck:0, &#125;; &#125;, // 检查当前li序号 methods:&#123; tabClass(index)&#123; this.itemCheck = index; // console.log(this.itemCheck); &#125; &#125;, // 防止刷新不对应变选中颜色 created()&#123; this.list.forEach((element,index) =&gt; &#123; for(let i in element)&#123; if(element[i].indexOf(this.$route.name) &gt;= 0)&#123; // this.$route当前路由对象（即网址对应的对象），对象名在index.js中已定义。 this.itemCheck = index; &#125; &#125; &#125;) &#125; #8安装axios 安装依赖 1cnpm install --save axios // --save 将其添加到 package.json 中 Vue中引入在main.js中添加 1import axios from 'axios' Vue中注册绑定在main.js中添加 1Vue.prototype.$axios = axios —————————前端工作基本结束，还有部分待会再根据后端接口来写————————— #9后端文件简介 主文件：app.js start文件：bin/www #10后端给接口比如users.js加几句123router.get('/user', function(req, res, next) &#123; res.send('respond with a resource');&#125;); #11前端Note.vue调接口123&lt;script&gt; export default &#123;……&#125;&lt;/script&gt; 中添加123456789mounted() &#123; this.$axios.get('http://localhost/users/user') .then((res)=&gt;&#123; console.log(res) &#125;) .catch((err)=&gt;&#123; console.log('接口调用不成功') &#125;) &#125;, tips：跨域调用接口不成功解决方法 **方法:1：Google Chrome右击属性目标添加下面字段 1--args --disable-web-security --user-data-dir **方法2：放到后端app.js文件里 1234app.all('*',function(req,res,next)&#123; res.header("Access-Control-Allow-Origin","*"); next();&#125;); #12用小工具使node不用重启即可在更改后刷新back中安装12cnpm -g install supervisorsupervisor ./bin/www #小结后端app.js有路由-&gt;routes/users.js-&gt;/users和/users/user前端12345mounted() &#123; this.$axios.get('……') // 网址 .then((res)=&gt;&#123;……&#125;) // 获取到数据操作 .catch((err)=&gt;&#123;……&#125;) // 报错操作&#125; #13前端打包1npm run build 打包后在dist目录下，将旗下static文件夹和index.html复制到back的public文件夹下 #14改后端路由 安装 1cnpm install --save connect-history-api-fallback app.js中引入下面4段代码 1var history = require('connect-history-api-fallback'); 1var noteRouter = require('./routes/note'); 12345678910app.use(history(&#123; rewrites: [ &#123; from: /^\/note\/.*$/, //有note处理，没有就有VueRouter处理 to: function(context) &#123; return context.parsedUrl.pathname; &#125; &#125; ]&#125;)) 1app.use('/note', noteRouter); 后端创建routes/note.js 123456789var express = require('express');var router = express.Router();/* GET getNote page. */router.get('/getNote', function(req, res, next) &#123; res.send('This is getNote');&#125;);module.exports = router; #15前端调用接口后端note.js1var fs = require('fs'); 1234router.get('/getNoteList', function(req, res, next) &#123; let files = findNoteList('./note'); res.json(files);&#125;); 12345678910function findNoteList(path)&#123; let result = []; let files = fs.readdirSync(path); //读取文件名 files.forEach(val=&gt;&#123; if(val.endsWith('.md'))&#123; result.push(val.split('.md')[0]); &#125; &#125;) return result;&#125; 前端Note.vue12345&lt;ul&gt; &lt;li class='list' v-for="item in noteList" :key="item"&gt; &#123;&#123;item&#125;&#125; &lt;/li&gt;&lt;/ul&gt; 12345678910mounted() &#123; this.$axios.get('http://localhost/note/getNoteList') .then((res)=&gt;&#123; this.noteList = res.data; console.log(this.noteList); &#125;) .catch((error)=&gt;&#123; console.log('接口调用不成功'); &#125;)&#125;]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java使用QRCode.jar生成与解析二维码]]></title>
    <url>%2F2019%2F04%2F16%2FJava%E4%BD%BF%E7%94%A8QRCode.jar%E7%94%9F%E6%88%90%E4%B8%8E%E8%A7%A3%E6%9E%90%E4%BA%8C%E7%BB%B4%E7%A0%81%2F</url>
    <content type="text"><![CDATA[这个是我根据好几个人的代码修改而成的生成并解读二维码的java程序 主要由3个文件组成：1.control.java2.MyQRCodeImage.java3.QRCode.jar 主要思路就是main函数控制encode类和decode类class encode生成并存储二维码图片class decode解码图片并输出二维码图片信息MyQRCodeImage.java是读取图片接口QRCode.jar是二维码相关运算的依赖包 去下面给出的地址下载QRCode.jar包，此jar包已经包括 生成与解析 。官网下载到的jar包是没有解析的。https://files.cnblogs.com/files/bigroc/QRCode.zip 特别感谢 bigroc 的文章《Java使用QRCode.jar生成与解析二维码》 代码如下：control.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//control.javapackage com.allenem.qrcode;import com.swetake.util.Qrcode;import jp.sourceforge.qrcode.QRCodeDecoder;import javax.imageio.ImageIO;import java.awt.*;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;import java.util.Random;public class control &#123; public static void main(String[] args) &#123; String data="https://github.com/Allenem"; long t = System.currentTimeMillis(); Random rand = new Random(t); int [][] r = new int[37][37]; for(int i=0; i&lt;37; i++) &#123; for(int j=0; j&lt;37; j++) &#123; r[j][i] = rand.nextInt(2); &#125; &#125; // 生成二维码 control.encode(data, "qrcodeimage/qrcode.jpg"); // 解析二维码 control.decode("qrcodeimage/qrcode.jpg"); &#125; //生成并输出二维码 private static boolean encode(String srcValue, String qrcodePicfilePath)&#123; int MAX_DATA_LENGTH = 200; byte[] d = srcValue.getBytes(); int dataLength = d.length; int imageWidth = 189; int imageHeight = imageWidth; BufferedImage bi = new BufferedImage(imageWidth, imageHeight,BufferedImage.TYPE_INT_RGB);//缓冲区 Graphics2D g = bi.createGraphics();//绘图 g.setBackground(Color.WHITE); g.clearRect(0, 0, imageWidth, imageHeight); g.setColor(Color.BLACK); if (dataLength &gt; 0 &amp;&amp; dataLength &lt;= MAX_DATA_LENGTH) &#123; Qrcode qrcode = new Qrcode(); /** * correction level分为 * level L : 最大 7% 的错误能够被纠正； * level M : 最大 15% 的错误能够被纠正； * level Q : 最大 25% 的错误能够被纠正； * level H : 最大 30% 的错误能够被纠正； */ qrcode.setQrcodeErrorCorrect('Q'); qrcode.setQrcodeEncodeMode('B');//注意版本信息 N代表数字 、A代表 a-z,A-Z、B代表其他 qrcode.setQrcodeVersion(5);//版本号 1-40 boolean[][] b = qrcode.calQrcode(d);//让字符串生成二维码 int qrcodeDataLen = b.length; for (int i = 0; i &lt; qrcodeDataLen; i++) &#123; for (int j = 0; j &lt; qrcodeDataLen; j++) &#123; if (b[j][i]) &#123; g.fillRect(j * 5 + 2, i * 5 + 2, 5, 5);//2为偏移量，5,5为矩形小块宽高 &#125; &#125; &#125; System.out.println("二维码成功生成！！"); &#125; else &#123; System.out.println( dataLength +"大于"+ MAX_DATA_LENGTH); return false; &#125; g.dispose(); bi.flush(); File f = new File(qrcodePicfilePath); String suffix = f.getName().substring(f.getName().indexOf(".")+1, f.getName().length()); System.out.println("二维码输出成功！！"); try &#123; ImageIO.write(bi, suffix, f); &#125; catch (IOException ioe) &#123; System.out.println("二维码生成失败" + ioe.getMessage()); &#125; return true; &#125; //解析二维码 private static String decode(String qrcodePicfilePath) &#123; System.out.println("开始解析二维码！！"); //读取二维码图像数据 File imageFile = new File(qrcodePicfilePath); BufferedImage image = null; try &#123; image = ImageIO.read(imageFile); &#125; catch (IOException e) &#123; System.out.println("读取二维码图片失败： " + e.getMessage()); return null; &#125; //解二维码 QRCodeDecoder decoder = new QRCodeDecoder(); String decodedData = new String(decoder.decode(new MyQRCodeImage(image))); //MyQRCodeImage要有接口文件 System.out.println("解析内容如下："+decodedData); return decodedData; &#125;&#125; MyQRCodeImage.java12345678910111213141516171819202122232425262728293031323334353637//MyQRCodeImage.javapackage com.allenem.qrcode;import jp.sourceforge.qrcode.data.QRCodeImage;import java.awt.image.BufferedImage;/** * 实现QRCodeImage接口， * 设置解码的图片信息 * 告诉codeDecoder.decode()将要解析的图片类型 */public class MyQRCodeImage implements QRCodeImage&#123; BufferedImage bufferedImage; public MyQRCodeImage(BufferedImage bufferedImage)&#123; this.bufferedImage=bufferedImage; &#125; //宽 @Override public int getWidth() &#123; return bufferedImage.getWidth(); &#125; //高 @Override public int getHeight() &#123; return bufferedImage.getHeight(); &#125; //像素还是颜色 @Override public int getPixel(int i, int j) &#123; return bufferedImage.getRGB(i,j); &#125;&#125; 文件框架如下： 效果图如下： 生成二维码图片如下：]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs->npm->cnpm->vue-cli的安装]]></title>
    <url>%2F2018%2F11%2F17%2Fnodejs%26npm%26cnpm%26vue-cli%E7%9A%84%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[参考 vue-cli 脚手架 安装和Windows10环境下安装Nodejs、cnpm #一、nodejs的安装 两个步骤： ####1.直接去官网（即https://nodejs.org/en/）下载安装包直接双击安装 安装成功后可以如下查看1$ node -v ####2.进入nodeJS的安装目录1npm install express -g （-g 表示全局安装） 1npm install jade 1npm install mysql #二、npm的安装 由于Nodejs自带了npm，所以你安装nodejs后，npm也会自行安装。接下来可以在命令行输入下面命令来检测安装成功和版本号：node -v 和npm -v。若出现不是内部命令看下一步。 一般安装完后，windows系统会将安装目录自带到系统变量Path路径后面，否则的话，就在windows设置环境变量的地方，将Nodejs安装路径添加到Path路径后面。（笔者此处是在Path后面新建E:\Program Files\nodejs）确认后，重启CMD，进行检测node和npm。 #三、cnpm的安装由于npm的镜像是国外的，为了加快下载速度，可以通过国内淘宝镜像来下载，所以采用cnpm，当然也可以不采用cnpm，直接把镜像指向淘宝镜像，接下来我说下这两种方式： ####方法1. 直接指定registry为淘宝镜像1npm config set registry https://registry.npm.taobao.org 然后若需要安装gulp和less，可以直接用1npm install gulp less --save-dev 就是从taobao镜像拿包了 ####方法2. 安装cnpm1npm install -g cnpm --registry=https://registry.npm.taobao.org 输入上述命令即可安装，另外要注意的是，安装完后，输入cnpm -v进行检测。由于笔者操作了第四步，cnpm跟npm是分开的，即npm里没有cnpm，之前设置的node环境变量对cnpm不起效，会出现输入cnpm不是内部命令这个问题，此时各位需要注意的是，一般这类问题都是跟环境变量有关，此时需要在环境变量Path路径后面加上E:\Program Files\nodejs\node_global，即cnpm脚本命令所在的文件夹目录下。 #四、vue-cli的安装1.安装完成node。node有自带的npm，可以直接在cmd中，找到nodeJs安装的路径下，进行命令行全局安装vue-cli。1npm install -g vue-cli // 加-g是安装到全局 想安装速度快点，可以使用淘宝镜像如下1npm install cnpm -g --registry=https://registry.npm.taobao.org 2.安装后，检查是否安装成功（显示版本则安装成功）查看vue版本（注意-V是大写）1vue -V //注意-V是大写 3.使用vue建一个项目，名叫“firstvueproject”1vue init webpack firstvueproject]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js学习总结——DOM获取元素的方法（8个）]]></title>
    <url>%2F2018%2F08%2F20%2Fjs%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94DOM%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[js学习总结——DOM获取元素的方法（8个）DOM:document object model 文档对象模型 DOM就是描述整个html页面中节点关系的图谱，可以如下图理解 在DOM中，提供了很多的获取元素的方法和之间关系的属性以及操作这些元素的方法。 获取页面中元素的方法如下 1）、在整个文档中，通过元素的ID获取到这个元素对象(获取的是一个元素)```1234567891011**注意:**如果页面中的id重复了，那么这个方法默认只获得第一个元素在ie6、7中,会把表单元素（input）的name属性值当做ID来使用在ie6、7中，不区分ID的大小写项目实战注意:不要让表单元素的name和其他元素的id重复，不要用id的大小写来区分我们的不同元素如果没有获取到，返回的 结果为null我们可以直接的用元素的id来代表当前元素对象（不推荐）## 2）、通过元素的标签名，来获取一组元素（有几个获取几个）```document.getElementsByTagName(&apos;元素的标签名&apos;) 在整个文档中，通过元素的标签名获取一组元素。获取的是一个对象数据类型结果，并且是一个类数组（以数字作为索引，索引从0开始，逐级递增，索引代表的是当前对应的某一个元素，有一个叫做length的属性代表获取的个数）document称之为上下文(context)，就是我们自己可以限定当前获取元素的范围[getElementById的上下文只能是document] 3）、通过元素的name属性的值获取一组元素1234567在ie浏览器下只对表单元素起作用这个方法应用于获取具有同样name的表单元素## 4）、通过元素的类名（class的值）```context.getElementsByClassName() 是项目中最常用的一种方法，但是在ie6-ie8中会报错。获取多个的这几个方法，即使你获取的只有一个，他也是类数组，也是一个集合，如果想用其中的第一个，你也要通过索引拿出来用。 5）、获取HTML元素1234例如：```document.body//获取body元素 curWidth 12```var curHeight = document.documentElement.clientHeight || document.body.clientHeight//兼容所有浏览器的获取当前屏幕的高度 6）在移动端我们回去元素常用的方法（IE6~8下不兼容）12document.querySelector()获取一个document.querySelectorAll()获取多个 querySelector、jquery中的选择器参考的是css选择器的规则]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git创建local repository和remote repository]]></title>
    <url>%2F2018%2F08%2F12%2FGit%E5%88%9B%E5%BB%BAlocal%20repository%E5%92%8Cremote%20repository%2F</url>
    <content type="text"><![CDATA[参考：①Git的使用–如何将本地项目上传到Github②Git教程 - 廖雪峰的官方网站 这篇文章主要讲Git本地仓库的创建及上传到GitHub的步骤Git的安装就不说了,直接上干货。 1、创建一个本地的版本库（其实也就是一个文件夹）。可以直接右击新建文件夹，也可以右击打开Git bash命令行窗口通过命令来创建。通过命令行在桌面新建一个TEST文件夹（你也可以在其他任何地方创建这个文件夹），并且进入这个文件夹 2、通过git init把它变成Git仓库；1$ git init 可以通过git status查看状态1$ git status 3、把项目复制到这个文件夹里面，再通过git add .把项目添加到仓库；1git add . 此时没有消息就是好消息,可以通过git status查看状态 4、告诉git你是谁12$ git config --global user.email "you@example.com"$ git config --global user.name "Your Name" 5、再通过git commit -m “注释内容”把项目提交到仓库；1$ git commit -m "first commit" 6、创建SSH KEY。先看一下C盘用户目录下有没有.ssh目录，有的话看下里面有没有id_rsa和id_rsa.pub这两个文件，有就跳到GitHub设置，没有就通过下面命令创建1$ ssh-keygen -t rsa -C "youremail@example.com" 然后一路回车。这时你就会在用户下的.ssh目录里找到id_rsa和id_rsa.pub这两个文件。 登录Github,找到右上角的图标，打开点进里面的Settings，再选中里面的SSH and GPG KEYS，点击右上角的New SSH key，然后Title里面随便填，再把刚才id_rsa.pub里面的内容复制到Title下面的Key内容框里面，最后点击Add SSH key，这样就完成了SSH Key的加密。 7、在Github上设置好SSH密钥后，新建一个远程仓库，通过git remote add origin https://github.com/Allenem/2048game.git将本地仓库和远程仓库进行关联；1$ git remote add origin https://github.com/Allenem/2048game.git 8、最后通过git push -u origin master把本地仓库的项目推送到远程仓库（也就是Github）上（若新建远程仓库的时候自动创建了README文件会报错，解决办法如下）。该步骤会要求输入name或email和登录密码登录来上传。1$ git push -u origin master 由于新建的远程仓库是空的，所以要加上-u这个参数，等远程仓库里面有了内容之后，下次再从本地库上传内容的时候只需下面这样就可以了：1$ git push origin master 这时候你再重新刷新你的Github页面进入刚才新建的那个仓库里面就会发现项目已经成功上传了： 注意：①创建远程仓库的时候，如果你勾选了Initialize this repository with a README（就是创建仓库的时候自动给你创建一个README文件），那么到了将本地仓库内容推送到远程仓库的时候就会报一个error：failed to push some refs to https://github.com/Allenem/2048game.git的错。 这是由于你新创建的那个仓库里面的README文件不在本地仓库目录中，这时我们可以通过以下命令先将内容合并以下：1$ git pull --rebase origin master 这时你再push就能成功了②若前面没提交仓库$ git commit -m “first commit”也会报错,完成该步骤即可。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2048游戏笔记]]></title>
    <url>%2F2018%2F07%2F24%2F2048%E6%B8%B8%E6%88%8F%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一、要实现的功能（一）期望1.4×4格子2.开始时随机出现两个数2或4，注意不能在同一格；之后每次移动后空白处随机出现一个数3.移动控制，横或纵数字一样才能合并，判断能否移动4.分数为合并数值累加5.颜色变化6.判败：①无空格②横或纵无相同数值7.判胜：某格数值为2048 （二）实现1.事件处理对象EventUtil 添加事件addHandler 移除事件removeHandler 获取事件对象getEvent 2.定义一些Game元素 tileContainer scoreEle bestScoreEle tiles 3.定义Game的prototype属性向对象添加属性 initEvent()初始化事件处理添加键盘谈起事件，防止一直按下重复触发，然后执行方块移动函数 init()初始化游戏创建空白方块坐标数组posArray和数值tiles[i][j] 清空全部方块初始化分数和最佳分数 随机创建2个方块 deleteTile(all,tile)清除dom节点清除所有 清除单个 newTile()创建新方块tile对象 位置*数值 setTile(element,num,x,y)设置方块显示数字和类 randomPos()方块的随机位置位置 从存空白坐标的数组中删除 moveTile(keyCode)方块移动处理leftMove(i,j)或rightMove(i,j)或upMove(i,j)或downMove(i,j) merge(i,j)*若合并了则newTile()；否则判断this.posArray.length==0&amp;&amp;this.gameOverTest()，若真执行gameOverMes() leftMove(i,j)i左一向左到0检测确定移动坐标及移动后数值 j不变 rightMove(i,j)i右一向右到tiles.length-1检测确定移动坐标及移动后数值 不变 upMove(i,j)j上一向上到0检测确定移动坐标及移动后数值 i不变 downMove(i,j)j下一向下到tiles.length-1检测确定移动坐标及移动后数值 i不变 merge(i,j)this.num的值变化:删除被覆盖的方块;将移到相同值的方块的位置上的方块的原始位置添加到存空白坐标的数组中 this.num的值不变:只需将空白数组中该空白方块的坐标改为移动的方块的原始坐标移动效果 设置tiles[this.moveI][this.moveJ]（将被覆盖的方块）*设置tiles[i][j]（将移动的方块） getScore(score)score bestScore gameWin()win continueBtn gameOverTest()检测this.leftMove(i,j)||this.rightMove(i,j)||this.upMove(i,j)||this.downMove(i,j)，只要有一个方向可以移动即退出return 否则return true gameOverMes创建元素message（三）2048小游戏思维导图 二、一些笔记1.EventUtil.addHandler方法EventUtil.addHandler： addHandler 方法，职责是分别视情况而定来使用DOM0级方法、DOM2级方法或IE方法来添加事件。 这个方法属于一个名字叫EventUtil的对象，可以使用这个对象来处理浏览器间的差异。 addHandler() 方法接受3个参数：要操作的元素、事件名称和事件处理程序函数。 与addHandler()方法对应的方法是removeHandler()，它也接受相同参数。这个方法的指责是移除之前添加的事件处理程序——-无论该事件处理程序是采取什么方式添加到元素中的。如果其他方法无效，默认采用DOM0级方法。 1234567891011121314151617181920212223242526272829303132//EventUtilvar EventUtil = &#123; //添加事件 addHandler: function (element, type, handler) &#123; if (element.addEventListener) &#123; //DOM2级 element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; //DOM1级 element.attachEvent("on" + type, handler); &#125; else &#123; element["on" + type] = handler; //DOM0级 &#125; &#125;, //移除事件 removeHandler: function (element, type, handler) &#123; //类似addHandler if (element.removeEventListener) &#123; element.removeEventListener(type, handler, false); &#125; else if (element.detachEvent) &#123; element.detachEvent("on" + type, handler); &#125; else &#123; element["on" + type] = null; &#125; &#125; //获取事件对象 getEvent:function(event)&#123; return event?event:window.event;//兼容ie &#125;&#125;var btn1 = document.getElementById("myBtn1");var handler = function () &#123; alert("hello handler");&#125;EventUtil.addHandler(btn1, "click", handler);//点击id为myBtn1按钮弹出hello handler提示框 用法：方法中首先检查DOM2级方法，如果DOM2级方法存在，则使用该方法：传入事件类型、事件处理程序、和第三个参数false（表示冒泡阶段）。 如果存在的是IE的方法，则采取第二种方案。（注意，为了在IE8及更早版本中运行，此时的事件类型必须加上“on”前缀。） 最后一种可能就是使用DOM0级方法。此时，我们使用的是括号语法来将属性名指定为事件处理程序，或者将事件设置为null。 2 JavaScript中的appendChild（）方法appendChild()方法是向节点添加最后一个子节点。也可以使用此方法从一个元素向另一个元素移动元素。 案例一：向节点添加最后一个子节点1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id="mylist"&gt; &lt;li&gt;牛奶&lt;/li&gt; &lt;li&gt;橡胶&lt;/li&gt; &lt;li&gt;花生&lt;/li&gt; &lt;/ul&gt; &lt;input type="text" id="listname" name="listname"/&gt; &lt;input type="button" value="添加列表项" onclick="mylist();"/&gt; &lt;script type="text/javascript"&gt; function mylist()&#123; var node=document.createElement("li"); //创建一个li节点 var testnode=document.getElementById("listname").value;//拿到input输入框的值 var asd=document.createTextNode(testnode)//定义创建文本节点 node.appendChild(asd); //把文本节点追加到li节点 document.getElementById("mylist").appendChild(node);//把li节点添加到ul中 &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 案例二：从一个元素向另一个元素移动123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id="mylist1"&gt; &lt;li&gt;牛奶&lt;/li&gt; &lt;li&gt;橡胶&lt;/li&gt; &lt;li&gt;花生&lt;/li&gt; &lt;/ul&gt; &lt;ul id="mylist2"&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;梨子&lt;/li&gt; &lt;li&gt;草莓&lt;/li&gt; &lt;/ul&gt; &lt;input type="button" value="点击移动" onclick="mylist();"/&gt; &lt;script type="text/javascript"&gt; function mylist()&#123; //定义节点 并把mylist2中的第一子节点赋值给node var node=document.getElementById("mylist2").firstChild; //将node里面获取的子节点 添加到mylisf1里面 document.getElementById("mylist1").appendChild(node); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 3. JavaScript forEach() 方法 (1)语法array.forEach(function(currentValue, index, arr), thisValue)(2)参数 参数 描述 function(currentValue, index, arr) 必需。 数组中每个元素需要调用的函数。 currentValue 必需。当前元素 index 可选。当前元素的索引值。 arr 可选。当前元素所属的数组对象。 thisValue 可选。传递给函数的值一般用 “this” 值。 如果这个参数为空， “undefined” 会传递给 “this” 值(3)技术细节返回值: undefinedJavaScript 版本: ECMAScript 3 4.css中@keyframes规则定义和用法通过 @keyframes 规则，能够创建动画。创建动画的原理是，将一套 CSS 样式逐渐变化为另一套样式。在动画过程中，能够多次改变这套 CSS 样式。以百分比来规定改变发生的时间，或者通过关键词 “from” 和 “to”，等价于 0% 和 100%。0% 是动画的开始时间，100% 动画的结束时间。 语法@keyframes animationname {keyframes-selector {css-styles;}} 值 描述 animationname 必需。定义动画的名称。 keyframes-selector 必需。动画时长的百分比。 - 合法的值：0-100%；from（与 0% 相同）；to（与 100% 相同） css-styles 必需。一个或多个合法的 CSS 样式属性。 实例 1在一个动画中添加多个 keyframe 选择器：试一试12345678910111213141516171819202122232425262728293031@keyframes mymove&#123;0% &#123;top:0px;&#125;25% &#123;top:200px;&#125;75% &#123;top:50px&#125;100% &#123;top:100px;&#125;&#125;@-moz-keyframes mymove /* Firefox */&#123;0% &#123;top:0px;&#125;25% &#123;top:200px;&#125;75% &#123;top:50px&#125;100% &#123;top:100px;&#125;&#125;@-webkit-keyframes mymove /* Safari and Chrome */&#123;0% &#123;top:0px;&#125;25% &#123;top:200px;&#125;75% &#123;top:50px&#125;100% &#123;top:100px;&#125;&#125;@-o-keyframes mymove /* Opera */&#123;0% &#123;top:0px;&#125;25% &#123;top:200px;&#125;75% &#123;top:50px&#125;100% &#123;top:100px;&#125;&#125; 5.CSS3 transition 属性定义和用法transition 属性是一个简写属性，用于设置四个过渡属性： transition-property transition-duration transition-timing-function transition-delay注释：请始终设置 transition-duration 属性，否则时长为 0，就不会产生过渡效果。 默认值： all 0 ease 0 继承性： no 版本： CSS3 JavaScript 语法： object.style.transition=”width 2s” 语法transition: property duration timing-function delay; 值 描述 transition-property 规定设置过渡效果的 CSS 属性的名称。 transition-duration 规定完成过渡效果需要多少秒或毫秒。 transition-timing-function 规定速度效果的速度曲线。 transition-delay 定义过渡效果何时开始。 例123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; /*光标停留时延时1s，宽从100变化为300用时2s，移开时延时1s，从300变为100用时2s*/div&#123;width:100px;height:100px;background:blue;transition:width 2s linear 1s;-moz-transition:width 2s linear 1s; /* Firefox 4 */-webkit-transition:width 2s linear 1s; /* Safari and Chrome */-o-transition:width 2s linear 1s; /* Opera */&#125;div:hover&#123;width:300px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;p&gt;请把鼠标指针移动到蓝色的 div 元素上，就可以看到过渡效果。&lt;/p&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;本例在 Internet Explorer 中无效。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 6.css媒体类型@media 规则@media 规则允许在相同样式表为不同媒体设置不同的样式。 实例6.1在下面的例子告诉我们浏览器屏幕上显示一个 14 像素的 Verdana 字体样式。但是如果页面打印，将是 10 个像素的 Times 字体。请注意，font-weight 在屏幕上和纸上设置为粗体：123456789101112@media screen&#123; p.test &#123;font-family:verdana,sans-serif;font-size:14px;&#125;&#125;@media print&#123; p.test &#123;font-family:times,serif;font-size:10px;&#125;&#125;@media screen,print&#123; p.test &#123;font-weight:bold;&#125;&#125; 实例6.2下面这个例子根据屏幕最大宽度设置显示宽度123456789101112@media only screen and (max-width: 700px)&#123; .responsive &#123; width: 49.99999%; margin: 6px 0; &#125;&#125;@media only screen and (max-width: 500px)&#123; .responsive &#123; width: 100%; &#125;&#125; 其他媒体类型注意：媒体类型名称不区分大小写。 媒体类型 描述 all 用于所有的媒体设备。 aural 用于语音和音频合成器。 braille 用于盲人用点字法触觉回馈设备。 embossed 用于分页的盲人用点字法打印机。 handheld 用于小的手持的设备。 print 用于打印机。 projection 用于方案展示，比如幻灯片。 screen 用于电脑显示器。 tty 用于使用固定密度字母栅格的媒体，比如电传打字机和终端。 tv 用于电视机类型的设备。 三、附：完整代码https://github.com/Allenem/2048game]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
</search>
